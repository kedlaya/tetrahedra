#include <iomanip>
#include <iostream>
#include <math.h>
#include <qd/qd_real.h>
#include <stdio.h>
#include <stdlib.h>
#include <vector>

using std::cout;
using std::endl;
using std::max;
using std::min;
using std::setprecision;
using std::vector;

int gcd(int a, int b);

double pi = acos(-1.);

int verbose = 2; // for controlling the output

// planes and lines below were determined experimentally

// first 6 entries are P, next 6 are U, next 6 are V. Plane is P + gamma1 U + gamma2 V
double planes[8][18] = {{.5, 0., 0., .5, 1., .5, 0, 2, 1, -1, -1, -1, 0, 0, 2, 0, -2, 0},  {0., .5, 1., .5, .5, 0., 1, -1, -2, 0, 1, 1, 2, 0, -1, -1, -1, 1},
                        {0., .5, 1., .5, .5, 0., 1, -1, -1, -1, 0, 2, 2, 0, -2, 0, 0, 0},  {0., .5, .5, 0., 1., .5, 1, -1, 0, 2, -1, -1, 2, 0, 0, 0, -2, 0},
                        {0., .5, .5, 0., 1., .5, 1, -1, 1, 1, -2, 0, 2, 0, -1, 1, -1, -1}, {0., .5, .5, 1., 0., .5, 1, -1, -1, -1, 2, 0, 2, 0, 0, -2, 0, 0},
                        {0., .5, 0., .5, .5, 1., 1, -1, 1, 1, 0, -2, 2, 0, 1, -1, -1, -1}, {0., .5, 0., .5, .5, 1., 0, 0, 2, 0, 0, -2, 2, 0, 1, -1, -1, -1}};

// first 6 entries are P, next 6 are U. Line is P + gamma U
double lines[144][12] = {{.6666666666666667, .5, .5, .3333333333333333, 0., .5, 0, -3, 1, 0, 2, 1},
                         {.6666666666666667, 1., .6666666666666667, 0., 0., 0., 0, -3, 0, 1, 1, 2},
                         {.6666666666666667, .6666666666666667, .3333333333333333, 0., .3333333333333333, .3333333333333333, 0, 1, 0, -3, -1, 2},
                         {.6666666666666667, .6666666666666667, .3333333333333333, 0., .3333333333333333, .3333333333333333, -1, 2, 0, -3, 0, 1},
                         {.5, .5, .5, .5, .3333333333333333, 0., -1, 1, -1, 3, 0, -4},
                         {.3333333333333333, .3333333333333333, .8333333333333333, .1666666666666667, .5, .5, 2, 2, -3, 1, -1, -3},
                         {.5, .3333333333333333, .6666666666666667, .5, 0., .5, 1, 0, 0, -3, 2, 1},
                         {.5, .5, .3333333333333333, .3333333333333333, .1666666666666667, .8333333333333333, -3, 3, -4, 0, 1, 5},
                         {.3333333333333333, .6666666666666667, .6666666666666667, 0., .6666666666666667, .3333333333333333, 2, -2, -1, 3, -3, -1},
                         {.5, .5, .6666666666666667, 0., .5, .5, -3, 3, 0, -4, 5, 1},
                         {.6666666666666667, 0., .6666666666666667, 1., 0., 0., 0, 1, 0, -3, 1, 2},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, 0., .3333333333333333, 0, 4, -1, -1, -3, -1},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, .3333333333333333, 0., 0, 4, -1, -1, -1, -3},
                         {.6666666666666667, 1., 0., 0., 0., 1., 0, -4, 3, 3, 1, -5},
                         {.5, .5, .5, .5, 0., .3333333333333333, -5, 1, 3, 3, -4, 0},
                         {.6666666666666667, 1., 0., 0., 1., 0., 0, -4, 3, 3, -5, 1},
                         {.5, .5, .5, .5, .3333333333333333, 0., -5, 1, 3, 3, 0, -4},
                         {.6666666666666667, .6666666666666667, 0., .3333333333333333, .3333333333333333, .3333333333333333, 0, -1, 3, 0, -2, 1},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, .3333333333333333, 0., 0, 1, -1, 2, 0, -3},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, .3333333333333333, 0., -1, 2, 0, 1, 0, -3},
                         {.6666666666666667, .6666666666666667, 0., .3333333333333333, .3333333333333333, .3333333333333333, 1, -2, 3, 0, -1, 0},
                         {.6666666666666667, 1., 0., 0., 0., .6666666666666667, 1, -3, 2, 2, 1, -3},
                         {.6666666666666667, 1., 0., 0., .6666666666666667, 0., 1, -3, 2, 2, -3, 1},
                         {.8333333333333333, .5, .3333333333333333, .3333333333333333, .1666666666666667, .1666666666666667, 1, -3, 0, 4, -1, -1},
                         {.3333333333333333, .3333333333333333, .5, .5, .1666666666666667, .8333333333333333, -1, -1, 0, 1, 0, 2},
                         {.3333333333333333, .3333333333333333, .5, .5, .8333333333333333, .1666666666666667, -1, -1, 0, 1, 2, 0},
                         {.3333333333333333, .3333333333333333, .8333333333333333, .1666666666666667, .5, .5, -2, -2, 3, -1, 3, 1},
                         {.5, .5, .3333333333333333, .3333333333333333, .1666666666666667, .8333333333333333, 0, -1, 1, 1, 0, -2},
                         {.5, .5, .3333333333333333, .3333333333333333, .8333333333333333, .1666666666666667, 0, -1, 1, 1, -2, 0},
                         {.5, 0., .6666666666666667, 1., 0., 0., 0, -1, 0, 2, -1, -1},
                         {.5, 0., 0., 0., 1., .6666666666666667, 0, 1, 1, 1, -2, 0},
                         {.5, 0., 0., 0., .6666666666666667, 1., 0, 1, 1, 1, 0, -2},
                         {.5, .1666666666666667, .1666666666666667, .1666666666666667, .6666666666666667, .6666666666666667, 0, 1, 2, 0, -1, -1},
                         {.3333333333333333, .6666666666666667, .5, .1666666666666667, .8333333333333333, .1666666666666667, -1, 1, 0, -1, 2, 0},
                         {.5, .5, .5, .5, .3333333333333333, 0., -1, 1, 0, 1, 0, -2},
                         {.3333333333333333, .6666666666666667, .1666666666666667, .1666666666666667, .5, .5, -1, 1, -2, 0, 1, 0},
                         {.3333333333333333, .6666666666666667, .5, .5, .1666666666666667, .1666666666666667, 2, -2, 1, -3, 1, 3},
                         {.5, .5, .5, .5, 0., .3333333333333333, -1, -1, 0, 3, -2, 0},
                         {.5, .5, .5, .5, .3333333333333333, 0., -1, -1, 0, 3, 0, -2},
                         {.5, .3333333333333333, .8333333333333333, .3333333333333333, .1666666666666667, .3333333333333333, 1, 0, -2, -1, 0, 3},
                         {.5, .1666666666666667, .8333333333333333, .1666666666666667, .3333333333333333, .6666666666666667, 1, 2, -2, 1, -2, -1},
                         {.5, .1666666666666667, .6666666666666667, .3333333333333333, .1666666666666667, .8333333333333333, 1, 2, 0, -1, 0, -3},
                         {.5, .5, .6666666666666667, 0., .5, .5, 1, -1, 0, 2, -3, 0},
                         {.5, .6666666666666667, .5, .3333333333333333, .5, 0., -2, 1, 2, 1, 1, -2},
                         {.5, .6666666666666667, .6666666666666667, .1666666666666667, .3333333333333333, .1666666666666667, -2, 1, 3, 0, 0, -1},
                         {.6666666666666667, 1., .5, 0., 0., 0., 0, -2, 0, 1, 1, 1},
                         {.6666666666666667, .3333333333333333, .5, .1666666666666667, .1666666666666667, .8333333333333333, 0, 1, -1, -2, 0, 3},
                         {.3333333333333333, .3333333333333333, .5, .5, .1666666666666667, .8333333333333333, 3, 1, -1, -1, 0, -4},
                         {.3333333333333333, .3333333333333333, .5, .5, .8333333333333333, .1666666666666667, 3, 1, -1, -1, -4, 0},
                         {.3333333333333333, .3333333333333333, .8333333333333333, .1666666666666667, .5, .5, 3, 1, -3, 1, -2, -2},
                         {.6666666666666667, 0., .5, 1., 0., 0., 0, -2, 0, 3, -1, -1},
                         {.6666666666666667, .6666666666666667, .1666666666666667, .1666666666666667, .5, .1666666666666667, 0, -1, 3, 0, -2, 1},
                         {.6666666666666667, .5, .1666666666666667, .3333333333333333, .6666666666666667, .1666666666666667, 0, 1, 2, -1, -3, 0},
                         {.5, .3333333333333333, .6666666666666667, .5, 0., .5, 2, -1, -1, -2, 2, 1},
                         {.5, .3333333333333333, .8333333333333333, .3333333333333333, .1666666666666667, .3333333333333333, 2, -1, -2, -1, 1, 2},
                         {.5, .5, 0., .3333333333333333, .5, .5, -1, 1, -2, 0, 1, 0},
                         {.5, .1666666666666667, .6666666666666667, .3333333333333333, .1666666666666667, .8333333333333333, 2, 1, -1, 0, 0, -3},
                         {.6666666666666667, .3333333333333333, .6666666666666667, .3333333333333333, 0., .5, -1, 1, 2, 0, -3, 0},
                         {.5, .1666666666666667, .8333333333333333, .1666666666666667, .3333333333333333, .6666666666666667, 2, 1, -2, 1, -1, -2},
                         {.6666666666666667, .3333333333333333, .6666666666666667, 0., .3333333333333333, .6666666666666667, -1, 1, -1, -3, 4, 0},
                         {.5, .6666666666666667, .3333333333333333, .1666666666666667, .6666666666666667, .1666666666666667, 2, -1, 0, 1, -3, 0},
                         {.5, .6666666666666667, .5, 0., .5, .3333333333333333, 2, -1, -1, 2, -2, -1},
                         {.6666666666666667, .6666666666666667, .5, .1666666666666667, .1666666666666667, .1666666666666667, -1, 2, 2, -1, -2, -1},
                         {.6666666666666667, .6666666666666667, .3333333333333333, 0., .3333333333333333, .3333333333333333, -1, -1, 1, -3, 4, 0},
                         {.6666666666666667, .6666666666666667, .3333333333333333, 0., .3333333333333333, .3333333333333333, -1, -1, 1, -3, 0, 4},
                         {.6666666666666667, .3333333333333333, .6666666666666667, 0., .3333333333333333, .6666666666666667, -2, 2, -1, -3, 3, 1},
                         {.6666666666666667, .6666666666666667, .1666666666666667, .1666666666666667, .5, .1666666666666667, 1, -2, 2, 1, -2, 1},
                         {.6666666666666667, .6666666666666667, .3333333333333333, 0., .3333333333333333, .3333333333333333, -3, 1, 1, -3, 2, 2},
                         {.3333333333333333, .3333333333333333, .3333333333333333, 0., .6666666666666667, .6666666666666667, 1, 1, 1, 3, -4, 0},
                         {.3333333333333333, .3333333333333333, .3333333333333333, 0., .6666666666666667, .6666666666666667, 1, 1, 1, 3, 0, -4},
                         {.5, .5, .5, .5, 0., .6666666666666667, -3, 3, 1, 5, -4, 0},
                         {.3333333333333333, .6666666666666667, .1666666666666667, .1666666666666667, .5, .5, 2, -2, 3, 1, -3, 1},
                         {.5, .5, .8333333333333333, .1666666666666667, .3333333333333333, .3333333333333333, -3, 3, 5, 1, 0, -4},
                         {.5, .3333333333333333, .5, 0., .5, .6666666666666667, 1, 0, 1, 2, -3, 0},
                         {.5, .5, 0., .3333333333333333, .5, .5, 1, -1, 4, 0, -3, 1},
                         {.6666666666666667, 0., 0., 0., 1., .6666666666666667, 0, 1, 2, 1, -3, 0},
                         {.6666666666666667, .3333333333333333, .8333333333333333, .1666666666666667, .1666666666666667, .5, -2, 2, 3, 1, -1, -3},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, 0., .3333333333333333, -1, -1, 0, 4, -3, 1},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, .3333333333333333, 0., -1, -1, 0, 4, 1, -3},
                         {.3333333333333333, .3333333333333333, .3333333333333333, 0., .6666666666666667, .6666666666666667, 3, -1, 1, 3, -2, -2},
                         {.8333333333333333, .1666666666666667, .5, .1666666666666667, .3333333333333333, .6666666666666667, -1, 1, 3, 1, -4, 0},
                         {.8333333333333333, .5, .1666666666666667, .1666666666666667, .3333333333333333, .3333333333333333, -1, 3, 1, 1, -4, 0},
                         {.8333333333333333, .5, .1666666666666667, .1666666666666667, .3333333333333333, .3333333333333333, -1, 3, 1, 1, 0, -4},
                         {.6666666666666667, 1., .6666666666666667, 0., 0., 0., -1, 3, 3, -1, -2, -2},
                         {.8333333333333333, .1666666666666667, .6666666666666667, .3333333333333333, .1666666666666667, .5, 1, -1, 0, 4, -1, -3},
                         {.6666666666666667, .3333333333333333, .5, .1666666666666667, .1666666666666667, .8333333333333333, 2, -2, 3, 1, -1, -3},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, 0., .3333333333333333, -3, 1, 2, 2, -3, 1},
                         {.6666666666666667, .6666666666666667, .3333333333333333, .3333333333333333, .3333333333333333, 0., -3, 1, 2, 2, 1, -3},
                         {.3333333333333333, .3333333333333333, .8333333333333333, .5, .1666666666666667, .1666666666666667, 1, 1, -3, -1, 0, 4},
                         {.3333333333333333, .3333333333333333, .8333333333333333, .5, .1666666666666667, .1666666666666667, 1, 1, -3, -1, 4, 0},
                         {.3333333333333333, .3333333333333333, .6666666666666667, .6666666666666667, 0., .3333333333333333, 1, 1, 0, -4, 3, 1},
                         {.3333333333333333, .3333333333333333, .6666666666666667, .6666666666666667, .3333333333333333, 0., 1, 1, 0, -4, 1, 3},
                         {.3333333333333333, .6666666666666667, .5, .5, .1666666666666667, .1666666666666667, -1, 1, 0, 1, 0, -2},
                         {.5, .5, .5, .5, 0., .6666666666666667, -1, 1, 0, 3, -2, 0},
                         {.5, .5, .6666666666666667, .3333333333333333, .1666666666666667, .1666666666666667, -1, 1, 3, -1, -4, 0},
                         {.5, .5, .3333333333333333, .3333333333333333, .1666666666666667, .8333333333333333, -2, 2, -5, 1, 1, 5},
                         {.5, .5, .6666666666666667, .3333333333333333, .1666666666666667, .1666666666666667, -2, 2, 3, -1, -3, -1},
                         {.5, .5, .6666666666666667, .3333333333333333, .1666666666666667, .1666666666666667, -2, -2, 5, 1, 1, -5},
                         {.5, .5, .6666666666666667, .3333333333333333, .1666666666666667, .1666666666666667, -2, -2, 5, 1, -5, 1},
                         {.5, .3333333333333333, .3333333333333333, .1666666666666667, .3333333333333333, .8333333333333333, 1, 0, 3, 0, -1, -2},
                         {.5, .5, .1666666666666667, .1666666666666667, .6666666666666667, .3333333333333333, 1, -1, 4, 0, -3, 1},
                         {.5, .8333333333333333, .1666666666666667, .1666666666666667, .3333333333333333, .3333333333333333, 1, -2, 2, 1, -2, 1},
                         {.5, .8333333333333333, .1666666666666667, .1666666666666667, .3333333333333333, .3333333333333333, 1, -2, 3, 0, -1, 0},
                         {.6666666666666667, .1666666666666667, .3333333333333333, .1666666666666667, .5, .6666666666666667, 0, 1, 3, 0, -2, -1},
                         {.3333333333333333, .3333333333333333, .6666666666666667, .6666666666666667, 0., .3333333333333333, 3, -1, -2, -2, 3, 1},
                         {.3333333333333333, .3333333333333333, .6666666666666667, .6666666666666667, .3333333333333333, 0., 3, -1, -2, -2, 1, 3},
                         {.3333333333333333, .3333333333333333, .8333333333333333, .5, .1666666666666667, .1666666666666667, 3, -1, -3, -1, 2, 2},
                         {.6666666666666667, .3333333333333333, .5, .1666666666666667, .1666666666666667, .8333333333333333, -1, 1, -4, 0, 1, 3},
                         {.5, .5, .6666666666666667, .3333333333333333, .1666666666666667, .1666666666666667, -5, 1, 5, 1, -2, -2},
                         {.6666666666666667, .6666666666666667, .5, .1666666666666667, .1666666666666667, .1666666666666667, -1, -1, 4, 0, 1, -3},
                         {.6666666666666667, .6666666666666667, .5, .1666666666666667, .1666666666666667, .1666666666666667, -1, -1, 4, 0, -3, 1},
                         {.5, .3333333333333333, .3333333333333333, .1666666666666667, .3333333333333333, .8333333333333333, 2, -1, 2, 1, -1, -2},
                         {.5, .3333333333333333, .5, 0., .5, .6666666666666667, 2, -1, 1, 2, -2, -1},
                         {.5, .5, .1666666666666667, .1666666666666667, .6666666666666667, .3333333333333333, 2, -2, 3, 1, -3, 1},
                         {.8333333333333333, .1666666666666667, .3333333333333333, .3333333333333333, .5, .5, 2, -2, -5, 1, 5, 1},
                         {.6666666666666667, .3333333333333333, .5, 0., .3333333333333333, .6666666666666667, 1, -1, 0, 3, 0, -2},
                         {.8333333333333333, .1666666666666667, .5, .1666666666666667, .3333333333333333, .6666666666666667, 1, -1, -4, 0, 3, 1},
                         {.6666666666666667, .6666666666666667, .5, .1666666666666667, .1666666666666667, .1666666666666667, -3, 1, 4, 0, -1, -1},
                         {.6666666666666667, .3333333333333333, .6666666666666667, .3333333333333333, 0., .6666666666666667, -1, 1, 0, 4, -3, -1},
                         {.6666666666666667, .3333333333333333, .6666666666666667, .3333333333333333, 0., .6666666666666667, -2, 2, 1, 3, -3, -1},
                         {.3333333333333333, .3333333333333333, .1666666666666667, .1666666666666667, .5, .8333333333333333, 1, 1, 4, 0, -1, -3},
                         {.3333333333333333, .3333333333333333, .1666666666666667, .1666666666666667, .8333333333333333, .5, 1, 1, 4, 0, -3, -1},
                         {.5, .5, .3333333333333333, .6666666666666667, .1666666666666667, .1666666666666667, -1, 1, -1, 3, 0, -4},
                         {.6666666666666667, .3333333333333333, .1666666666666667, .1666666666666667, .5, .5, 0, -4, -5, 1, 3, 3},
                         {.5, .5, .3333333333333333, .6666666666666667, .1666666666666667, .1666666666666667, -2, 2, -1, 3, -1, -3},
                         {.6666666666666667, .3333333333333333, .8333333333333333, .1666666666666667, .1666666666666667, .5, -1, 1, 3, 1, 0, -4},
                         {.3333333333333333, .3333333333333333, .1666666666666667, .1666666666666667, .5, .8333333333333333, 3, -1, 2, 2, -1, -3},
                         {.3333333333333333, .3333333333333333, .1666666666666667, .1666666666666667, .8333333333333333, .5, 3, -1, 2, 2, -3, -1},
                         {.6666666666666667, .6666666666666667, .1666666666666667, .1666666666666667, .1666666666666667, .5, 1, 1, 3, -1, 0, -4},
                         {.6666666666666667, .6666666666666667, .1666666666666667, .1666666666666667, .5, .1666666666666667, 1, 1, 3, -1, -4, 0},
                         {.8333333333333333, .1666666666666667, .6666666666666667, .3333333333333333, .1666666666666667, .5, 1, -1, 1, 3, 0, -4},
                         {.5, .5, .3333333333333333, 0., .5, .5, -5, 1, 0, -4, 3, 3},
                         {.6666666666666667, .6666666666666667, .1666666666666667, .1666666666666667, .1666666666666667, .5, 3, -1, 1, 1, 0, -4},
                         {.6666666666666667, .6666666666666667, .1666666666666667, .1666666666666667, .5, .1666666666666667, 3, -1, 1, 1, -4, 0},
                         {.5, .5, .8333333333333333, .1666666666666667, .3333333333333333, .3333333333333333, -2, 2, 5, 1, 1, -5},
                         {.5, .5, .3333333333333333, 0., .5, .5, 1, 1, 0, 2, -3, 0},
                         {.5, .5, .3333333333333333, 0., .5, .5, 1, 1, 0, 2, 0, -3},
                         {.6666666666666667, 0., 0., 0., 1., .5, 0, 2, 1, 1, -3, 0},
                         {.6666666666666667, 0., 0., 0., .5, 1., 0, 2, 1, 1, 0, -3},
                         {.8333333333333333, .1666666666666667, .5, .5, .3333333333333333, .3333333333333333, 2, -2, 1, 5, 1, -5},
                         {.5, .5, .1666666666666667, .1666666666666667, .3333333333333333, .6666666666666667, 2, 2, 5, -1, -1, -5},
                         {.5, .5, .1666666666666667, .1666666666666667, .6666666666666667, .3333333333333333, 2, 2, 5, -1, -5, -1},
                         {.5, .5, .1666666666666667, .1666666666666667, .3333333333333333, .6666666666666667, 5, -1, 2, 2, -1, -5},
                         {.5, .5, .1666666666666667, .1666666666666667, .6666666666666667, .3333333333333333, 5, -1, 2, 2, -5, -1}};

// for storing solutions to the gram determinant equation
class soln {

public:
  int n;   // the denominator
  int m12; // the numerators
  int m13;
  int m14;
  int m23;
  int m24;
  int m34;
  int a;     // the gcd of all the m's with n a=gcd(m,m12,m13,m14,m23,m24,m34)
  int loner; // for degenerate solutions, stores the index of the vector that lies outside the common plane
};

class plane {

public:
  // points on the plane are given by P + t1 U + t2 V, where P,U,V are in R^6
  double P[6];
  double U[6];
  double V[6];
  int loner;

  plane(soln s1, soln s2, soln s3) {

    loner = s1.loner; // we only get here if the 3 solns are in the same loner class, so ok to assign the value of s1.loner, since s1.loner = s2.loner = s3.loner

    double x1, x2, x3;
    x1 = 1. / s1.n;
    x2 = 1. / s2.n;
    x3 = 1. / s3.n;

    P[0] = s1.m12 * x1;
    P[1] = s1.m13 * x1;
    P[2] = s1.m14 * x1;
    P[3] = s1.m23 * x1;
    P[4] = s1.m24 * x1;
    P[5] = s1.m34 * x1;

    U[0] = s2.m12 * x2 - s1.m12 * x1;
    U[1] = s2.m13 * x2 - s1.m13 * x1;
    U[2] = s2.m14 * x2 - s1.m14 * x1;
    U[3] = s2.m23 * x2 - s1.m23 * x1;
    U[4] = s2.m24 * x2 - s1.m24 * x1;
    U[5] = s2.m34 * x2 - s1.m34 * x1;

    V[0] = s3.m12 * x3 - s1.m12 * x1;
    V[1] = s3.m13 * x3 - s1.m13 * x1;
    V[2] = s3.m14 * x3 - s1.m14 * x1;
    V[3] = s3.m23 * x3 - s1.m23 * x1;
    V[4] = s3.m24 * x3 - s1.m24 * x1;
    V[5] = s3.m34 * x3 - s1.m34 * x1;

    if (verbose > 2) {
      cout << "CONSTRUCTOR PLANE ";
      cout << setprecision(10);
      cout << P[0] << " ";
      cout << P[1] << " ";
      cout << P[2] << " ";
      cout << P[3] << " ";
      cout << P[4] << " ";
      cout << P[5] << " : ";
      cout << U[0] << " ";
      cout << U[1] << " ";
      cout << U[2] << " ";
      cout << U[3] << " ";
      cout << U[4] << " ";
      cout << U[5] << " : ";
      cout << V[0] << " ";
      cout << V[1] << " ";
      cout << V[2] << " ";
      cout << V[3] << " ";
      cout << V[4] << " ";
      cout << V[5] << endl;
    }

    // nicer output, assumes n is the same for all 3 points
    // this assumption need not be the case if we run on several n's together.
    int n = s1.n;

    if (verbose > 1) {
      cout << loner << " [[";

      cout << P[0] << ",";
      cout << P[5] << ",";
      cout << P[1] << ",";
      cout << P[4] << ",";
      cout << P[2] << ",";
      cout << P[3] << "],[";

      cout << U[0] * n << ",";
      cout << U[5] * n << ",";
      cout << U[1] * n << ",";
      cout << U[4] * n << ",";
      cout << U[2] * n << ",";
      cout << U[3] * n << "],[";

      cout << V[0] * n << ",";
      cout << V[5] * n << ",";
      cout << V[1] * n << ",";
      cout << V[4] * n << ",";
      cout << V[2] * n << ",";
      cout << V[3] * n << "]]," << endl;
    }
  }
  // for constructing a plane from a precomputed plane
  plane(double v[18]) {

    loner = 5;

    P[0] = v[0];
    P[5] = v[1];
    P[1] = v[2];
    P[4] = v[3];
    P[2] = v[4];
    P[3] = v[5];

    U[0] = v[6];
    U[5] = v[7];
    U[1] = v[8];
    U[4] = v[9];
    U[2] = v[10];
    U[3] = v[11];

    V[0] = v[12];
    V[5] = v[13];
    V[1] = v[14];
    V[4] = v[15];
    V[2] = v[16];
    V[3] = v[17];
    if (verbose > 2) {
      cout << "CONSTRUCTOR PLANE ";
      cout << setprecision(10);
      cout << P[0] << " ";
      cout << P[1] << " ";
      cout << P[2] << " ";
      cout << P[3] << " ";
      cout << P[4] << " ";
      cout << P[5] << " : ";
      cout << U[0] << " ";
      cout << U[1] << " ";
      cout << U[2] << " ";
      cout << U[3] << " ";
      cout << U[4] << " ";
      cout << U[5] << " : ";
      cout << V[0] << " ";
      cout << V[1] << " ";
      cout << V[2] << " ";
      cout << V[3] << " ";
      cout << V[4] << " ";
      cout << V[5] << endl;
    }
  }
};

bool is_in_plane(soln s, plane Q) {

  bool are_ind = false; // check if two rows of the 6x2 matrix UV are independent. Use to solve
                        // for t1 and t2 in P + t1 U + t2 V = S, by considering the first two entries of the equation,
                        // i.e. the 2x2 system of equations in
                        // t1 and t2, where S is the transpose of
                        // (m12,m34,...) of the soln s. Then see if this matches all the other entries of S.
                        // If so, declare the solution s as lying in the plane Q.

  int i, j;
  double d;
  double t1, t2;

  double x[6];

  double y = 1. / s.n;
  x[0] = s.m12 * y - Q.P[0]; // used to solve for t1 and t2 in t1 U + t2 V = S-P
  x[1] = s.m13 * y - Q.P[1];
  x[2] = s.m14 * y - Q.P[2];
  x[3] = s.m23 * y - Q.P[3];
  x[4] = s.m24 * y - Q.P[4];
  x[5] = s.m34 * y - Q.P[5];

  for (j = 1; j <= 5 && !are_ind; j++)
    for (i = 0; i < j && !are_ind; i++) {
      d = Q.V[j] * Q.U[i] - Q.V[i] * Q.U[j];
      if (d > 1e-11 || d < -1e-11) { // the i and j rows of UV are independent
        are_ind = true;
        // solve for t1 and t2 by inverting the 2x2 matrix
        t1 = (Q.V[j] * x[i] - Q.V[i] * x[j]) / d;
        t2 = (-Q.U[j] * x[i] + Q.U[i] * x[j]) / d;
      }
    }
  i--;
  j--;

  if (are_ind) {

    double y = 0;
    double r;

    for (i = 0; i <= 5; i++) {
      r = t1 * Q.U[i] + t2 * Q.V[i] - x[i]; // difference between t1 U + t2 V and X, entry wise
      y += r * r;                           // || t1 U + t2 V - X ||^2
    }
    if (y < 1e-11) {
      return true; // S is in the plane
    }
  }
  return false; // S is not in the plane
}

// test if 3 solutions lie on a line. Do so via the dot product to measure the
// angle (actually, cos^2 of the angle) between soln2 - soln1 and soln3 - soln1
bool is_on_line(soln soln1, soln soln2, soln soln3, bool do_print = false) {

  double x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;

  double c1, c2, c3;
  c1 = 1. / soln1.n;
  c2 = 1. / soln2.n;
  c3 = 1. / soln3.n;

  x1 = soln2.m12 * c2 - soln1.m12 * c1;
  x2 = soln2.m13 * c2 - soln1.m13 * c1;
  x3 = soln2.m14 * c2 - soln1.m14 * c1;
  x4 = soln2.m23 * c2 - soln1.m23 * c1;
  x5 = soln2.m24 * c2 - soln1.m24 * c1;
  x6 = soln2.m34 * c2 - soln1.m34 * c1;

  y1 = soln3.m12 * c3 - soln1.m12 * c1;
  y2 = soln3.m13 * c3 - soln1.m13 * c1;
  y3 = soln3.m14 * c3 - soln1.m14 * c1;
  y4 = soln3.m23 * c3 - soln1.m23 * c1;
  y5 = soln3.m24 * c3 - soln1.m24 * c1;
  y6 = soln3.m34 * c3 - soln1.m34 * c1;

  double c, d, e;

  d = x1 * y1 + x2 * y2 + x3 * y3 + x4 * y4 + x5 * y5 + x6 * y6;

  double XX, YY;
  XX = x1 * x1 + x2 * x2 + x3 * x3 + x4 * x4 + x5 * x5 + x6 * x6;
  YY = y1 * y1 + y2 * y2 + y3 * y3 + y4 * y4 + y5 * y5 + y6 * y6;

  if (do_print)
    cout << "XX: " << XX << " YY: " << YY << endl;

  // if 2 of the points coincide, so that we have at most 2 distinct points, then they are on a line
  if (XX < 1e-22 || YY < 1e-22)
    return true;

  else
    e = XX * YY; // i.e. || x || || y ||, squared

  c = d * d / e; // i.e. c is cos^2 of the angle between soln2 - soln1 and soln3 - soln1

  if (do_print)
    cout << "cos^2: " << c << endl;

  if (1 - c < 1e-11) {
    if (do_print) {
      cout << "IS ON A LINE" << endl;
      cout << x1 << " ";
      cout << x2 << " ";
      cout << x3 << " ";
      cout << x4 << " ";
      cout << x5 << " ";
      cout << x6 << endl;
      cout << y1 << " ";
      cout << y2 << " ";
      cout << y3 << " ";
      cout << y4 << " ";
      cout << y5 << " ";
      cout << y6 << endl;
    }
    return true;
  } // i.e. if the cos^2 is very close to 1

  return false;
}

// for storing lines
class line {

public:
  // points on the plane are given by P + t U,  where P,U are in R^6
  double P[6];
  double U[6];

  // construct a line from two points on the line
  line(soln s1, soln s2) {

    double x1, x2;
    x1 = 1. / s1.n;
    x2 = 1. / s2.n;

    P[0] = s1.m12 * x1;
    P[1] = s1.m13 * x1;
    P[2] = s1.m14 * x1;
    P[3] = s1.m23 * x1;
    P[4] = s1.m24 * x1;
    P[5] = s1.m34 * x1;

    U[0] = s2.m12 * x2 - s1.m12 * x1;
    U[1] = s2.m13 * x2 - s1.m13 * x1;
    U[2] = s2.m14 * x2 - s1.m14 * x1;
    U[3] = s2.m23 * x2 - s1.m23 * x1;
    U[4] = s2.m24 * x2 - s1.m24 * x1;
    U[5] = s2.m34 * x2 - s1.m34 * x1;

    if (verbose > 1) {
      cout << "CONSTRUCTOR LINE ";
      cout << setprecision(10);
      cout << P[0] << " ";
      cout << P[1] << " ";
      cout << P[2] << " ";
      cout << P[3] << " ";
      cout << P[4] << " ";
      cout << P[5] << " : ";
      cout << U[0] << " ";
      cout << U[1] << " ";
      cout << U[2] << " ";
      cout << U[3] << " ";
      cout << U[4] << " ";
      cout << U[5] << endl;
    }

    // nicer output, assumes n is the same for all 3 points
    int n = s1.n;

    if (verbose > 1) {
      cout << "[[";

      cout << P[0] << ",";
      cout << P[5] << ",";
      cout << P[1] << ",";
      cout << P[4] << ",";
      cout << P[2] << ",";
      cout << P[3] << "],[";

      cout << U[0] * n << ",";
      cout << U[5] * n << ",";
      cout << U[1] * n << ",";
      cout << U[4] * n << ",";
      cout << U[2] * n << ",";
      cout << U[3] * n << "]]," << endl;
    }
  }

  // for constructing a line from a precomputed line
  line(double v[12]) {

    P[0] = v[0];
    P[5] = v[1];
    P[1] = v[2];
    P[4] = v[3];
    P[2] = v[4];
    P[3] = v[5];

    U[0] = v[6];
    U[5] = v[7];
    U[1] = v[8];
    U[4] = v[9];
    U[2] = v[10];
    U[3] = v[11];

    if (verbose > 2) {
      cout << "CONSTRUCTOR LINE ";
      cout << setprecision(10);
      cout << P[0] << " ";
      cout << P[1] << " ";
      cout << P[2] << " ";
      cout << P[3] << " ";
      cout << P[4] << " ";
      cout << P[5] << " : ";
      cout << U[0] << " ";
      cout << U[1] << " ";
      cout << U[2] << " ";
      cout << U[3] << " ";
      cout << U[4] << " ";
      cout << U[5] << endl;
    }
  }
};

// measure the distance squared between two solutions
double diff(soln s1, soln s2) {

  double x1, x2;
  double U[6];
  x1 = 1. / s1.n;
  x2 = 1. / s2.n;

  U[0] = s2.m12 * x2 - s1.m12 * x1;
  U[1] = s2.m13 * x2 - s1.m13 * x1;
  U[2] = s2.m14 * x2 - s1.m14 * x1;
  U[3] = s2.m23 * x2 - s1.m23 * x1;
  U[4] = s2.m24 * x2 - s1.m24 * x1;
  U[5] = s2.m34 * x2 - s1.m34 * x1;

  return (U[0] * U[0] + U[1] * U[1] + U[2] * U[2] + U[3] * U[3] + U[4] * U[4] + U[5] * U[5]);
}

// test if a soln s lies on a given line L = P + t U. Do so via the dot product to measure the
// angle (actually, cos^2 of the angle) between P - s and U. Returns true if cos^2 is within 10^{-12} of 1.
bool is_on_line(soln s, line L) {

  double x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;

  double c1;
  c1 = 1. / s.n;

  x1 = s.m12 * c1 - L.P[0];
  x2 = s.m13 * c1 - L.P[1];
  x3 = s.m14 * c1 - L.P[2];
  x4 = s.m23 * c1 - L.P[3];
  x5 = s.m24 * c1 - L.P[4];
  x6 = s.m34 * c1 - L.P[5];

  y1 = L.U[0];
  y2 = L.U[1];
  y3 = L.U[2];
  y4 = L.U[3];
  y5 = L.U[4];
  y6 = L.U[5];

  double c, d, e;

  d = x1 * y1 + x2 * y2 + x3 * y3 + x4 * y4 + x5 * y5 + x6 * y6;

  double XX, YY;
  XX = x1 * x1 + x2 * x2 + x3 * x3 + x4 * x4 + x5 * x5 + x6 * x6;
  YY = y1 * y1 + y2 * y2 + y3 * y3 + y4 * y4 + y5 * y5 + y6 * y6;

  // if s coincides with P, to within around 10^{-10} per coordinate, then proclaim s is on the line
  if (XX < 1e-22)
    return true;

  else
    e = XX * YY; // i.e. || x || || y ||, squared

  c = d * d / e; // i.e. c is cos^2 of the angle between s - P and U

  if (1 - c < 1e-11) {
    return true;
  } // i.e. if the cos^2 is very close to 1

  return false;
}

// for debugging purposes. Not currently used
void print_soln(soln s) {

  cout << s.n << " : ";
  cout << s.m12 << " ";
  cout << s.m34 << " ";
  cout << s.m13 << " ";
  cout << s.m24 << " ";
  cout << s.m14 << " ";
  cout << s.m23 << " gcd ";
  cout << s.a << endl;
}

// test whether (A P1 + B P2 + C P3)/(A+B+C), is also a solution, to within 10^(-12), of the determinant equation
// for given A,B,C.
bool gives_planar_family(soln soln1, soln soln2, soln soln3, double A, double B, double C, bool do_print = false) {

  double A1, B1, C1;
  double E;

  E = A + B + C;
  A1 = A / (E * soln1.n);
  B1 = B / (E * soln2.n);
  C1 = C / (E * soln3.n); // we also normalize by the corresponding n

  double a12, a13, a14, a23, a24, a34; // angles as rational numbers, without the pi's
  double c12, c13, c14, c23, c24, c34; // cosines (with the pi's)
  double Det;

  a12 = A1 * soln1.m12 + B1 * soln2.m12 + C1 * soln3.m12;
  a13 = A1 * soln1.m13 + B1 * soln2.m13 + C1 * soln3.m13;
  a14 = A1 * soln1.m14 + B1 * soln2.m14 + C1 * soln3.m14;
  a23 = A1 * soln1.m23 + B1 * soln2.m23 + C1 * soln3.m23;
  a24 = A1 * soln1.m24 + B1 * soln2.m24 + C1 * soln3.m24;
  a34 = A1 * soln1.m34 + B1 * soln2.m34 + C1 * soln3.m34;

  c12 = cos(a12 * pi);
  c13 = cos(a13 * pi);
  c14 = cos(a14 * pi);
  c23 = cos(a23 * pi);
  c24 = cos(a24 * pi);
  c34 = cos(a34 * pi);

  // check if the linear combination satisfies the determinant condition
  Det = 1 - c34 * c34 - c23 * c23 - c24 * c24 - c12 * c12 + c12 * c12 * c34 * c34;
  Det = Det - c13 * c13 * (1 - c24 * c24) - c14 * c14 * (1 - c23 * c23);
  Det = Det - 2 * (c23 * c24 * c34 + c12 * c23 * c13 + c12 * c23 * c14 * c34);
  Det = Det - 2 * (c12 * c24 * c13 * c34 + c12 * c24 * c14 + c13 * c14 * c34 + c13 * c24 * c14 * c23);
  if (do_print)
    cout << "in planar test, DET : " << Det << endl;

  if (Det < 1e-11 and Det > -1e-11) {
    return true;
  }

  return false;
}

vector<plane> planar_families;
vector<line> linear_families;

int main() {


  int N1, N2; // starting and ending n, N1 <= n <= N2.
  int i, j, k, l, m, n;

  int a, b;
  double det, Det, Det2;                           // used for storing determinants
  double det12, det34, det13, det24, det14, det23; // used to build up the determinant of the gram matrix efficiently

  double c12, c13, c14, c23, c24, c34;       // for calling up cosines
  double c12b, c13b, c14b, c23b, c24b, c34b; // for calling up cosines squared
  int m12, m13, m14, m23, m24, m34;          // for looping over the possible angles

  int m23_0; //used to rule out the case where the two solutions to the quadratic equation are the same, i.e. discriminant 0 case

  double COS[421][421]; //for storing cosines
  double COSb[421][421]; //for storing cosines squared

  double y, y1, y2, y3, x2; // various temporary doubles

  double theta1, theta2; // used when determining m23 by solving a quadratic eqn
  double n_over_pi;

  qd_real theta1_qd, theta2_qd;
  double c2434, c1213, c1224, c1334; // stores, -2 c24 * c34, etc. Note the extra -2, theta2_qd;
  double c1234, c1324, c1423;        // stores, c12 * c34, etc. No extra factors

  double c1213_2434; // c1213+c2434 inherits the extra factor of -2
  double c1224_1334; // c1224+c1334 inherits the extra factor of -2

  double c1324_1234; // c1324+c1234 no extra -2

  double A, B, C;

  double max_err=0.; //to keep track of loss of precision in acos computation

  qd_real zero = "0.";
  qd_real one = "1.";
  qd_real two = "2.";
  qd_real pi_qd = acos(-one);

  qd_real x1_qd, x2_qd;

  static qd_real COS_qd[421][421]; //for storing cosines with quad double precision
  static qd_real COSb_qd[421][421];  //for storing cosines squared with quad double precision
  qd_real y_qd, Det_qd;
  qd_real c12_qd, c13_qd, c14_qd, c23_qd, c24_qd, c34_qd;       // for calling up cosines
  qd_real c12b_qd, c13b_qd, c14b_qd, c23b_qd, c24b_qd, c34b_qd; // for calling up cosines

  qd_real det_11, det_22, det_33, det_44; // the 4 diagonal cofactors
  qd_real det1, det2, det3, det4;         // the bottom 4 cofactors

  static soln degenerate_solns[3000000]; // safely enough for all n <= 280, simultaneously, and also for smaller sets of larger n's
  static soln lemmaB_solns[100000];      // safely enough for all n <= 280, simultaneously, and also for smaller sets of larger n's
  static soln lemmaC_solns[20000];       // safely enough for all n <= 280, simultaneously, and also for smaller sets of larger n's

  vector<soln> solns_to_process; // used in keeping track of which solutions are left after removing those on planes,
                                 // then on lines, down to sporadics.

  vector<soln> sporadic_solns;
  int count_degenerate = 0;
  int count_lemmaB = 0;
  int count_lemmaC = 0;

  soln soln1, soln2, soln3; //, soln4;

  long long count_m23=0;
  long long count_m23qd=0;

  // add the 8 known planes to the vector of planes
  for (j = 0; j < 8; j++) {
    plane Q = plane(planes[j]);
    planar_families.push_back(Q);
  }
  // add the 144 known lines to the vector of lines
  for (j = 0; j < 144; j++) {
    line L = line(lines[j]);
    linear_families.push_back(L);
  }

  qd_real max_cos_diff=0.;
  for (n = 2; n <= 420; n++)
    for (i = 1; i <= n; i++) {
      y = cos(i * pi / n);
      COS[n][i] = y;      // stores values of cos
      COSb[n][i] = y * y; // stores values of cos^2

      // the _qd values are for doing things in quad double precision
      y_qd = cos(i * pi_qd / n);
      COS_qd[n][i] = y_qd;         // stores values of - cos
      COSb_qd[n][i] = y_qd * y_qd; // stores values of cos^2

      qd_real diff=abs(qd_real(COS[n][i])-COS_qd[n][i]);
      if(diff>max_cos_diff){
        max_cos_diff =diff;
        cout << "MAX_COS_DIFF: " << max_cos_diff <<endl;
      }
    }

  // The gram matrix
  //
  // [   1     c12   c13   c14 ]
  // [                         ]
  // [  c12    1     c23   c24 ]
  // [                         ]   has deteterminant...
  // [  c13   c23    1     c34 ]
  // [                         ]
  // [  c14   c24   c34    1   ]
  //
  //        2      2                      2      2      2    2
  // 1 - c34  - c23  - 2 c23 c24 c34 - c24  - c12  + c12  c34  - 2 c12 c13 c23
  //
  //                                                                   2      2    2
  //      - 2 c12 c23 c14 c34 - 2 c12 c24 c13 c34 - 2 c12 c24 c14 - c13  + c13  c24
  //
  //                                               2      2    2
  //      - 2 c13 c14 c34 - 2 c13 c14 c24 c23 - c14  + c14  c23
  //
  // Below, we compute the terms of this expression the moment they become available within each of the loops over the various mij's

  cout <<"Enter starting n and finishing n: " << endl;

  scanf("%d %d", &N1, &N2);
  for (n = N1; n <= N2; n++) {

    bool newline_needed = false; // used in outputting the results

    n_over_pi = n / pi;

    for (m12 = 1; m12 < n; m12++) {
      c12 = COS[n][m12];
      c12b = COSb[n][m12];
      det12 = 1 - c12b;

      for (m34 = 1; m34 <= m12; m34++) {
        c34 = COS[n][m34];
        c34b = COSb[n][m34];
        det34 = det12 - c34b + c12b * c34b;

        c1234 = c12 * c34;

        for (m13 = 1; m13 < m12 + m34 && m13 < n; m13++) {
          c13 = COS[n][m13];
          c13b = COSb[n][m13];
          det13 = det34 - c13b;

          c1213 = -2 * c12 * c13;
          c1334 = -2 * c13 * c34;

          for (m24 = 1; m24 + m13 <= m12 + m34 && m24 <= m13; m24++) {
            c24 = COS[n][m24];
            c24b = COSb[n][m24];

            c2434 = -2 * c24 * c34;
            c1224 = -2 * c12 * c24;

            c1213_2434 = c1213 + c2434;
            c1224_1334 = c1224 + c1334;

            c1324 = c13 * c24;

            c1324_1234 = c1324 + c1234;

            det24 = det13 - c24b + c13b * c24b - 2 * c1234 * c1324;

            for (m14 = 1; m14 < m13 + m24 && m14 < n; m14++) {
              bool relevant_m23_1=false;
              bool relevant_m23_2=false;
              c14 = COS[n][m14];
              c14b = COSb[n][m14];

              det14 = det24 - c14b + c14 * c1224_1334;

              // the commented loop over m23 is now replaced by solving for m23 via a quadratic equation in c23,
              // for(m23=1;m14+m23<=m13+m24;m23++){

              A = c14b - 1;
              B = c1213_2434 - 2 * c14 * c1324_1234;
              C = det14;
              // if the gram matrix has det 0, then c23 satisfies the quadratic equation
              // A x^2 +B x + C = 0. Below, x2 is used to store the two solutions. In the event that
              // the discriminant B^2 - 4AC equals zero, then we only use the one (repeated) solution to the quadratic equation.
              // XX below is used to loop through the two solutions.

              y = B * B - 4 * A * C;

              if (y >= -1e-11) { // if non-negative, roughly,

                if(y<0) y = 0;
                //Sometimes, when the true value of B^2-4AC is zero,
                //y ends up as very slightly negative, due to round off, certainly within -1e-11. There's no harm, below, in rounding
                //that to 0 since we end up solving for m_23/n pi by taking an acos, with n<=420.
                //But cos(x) = -(x-Pi/2) + 1/6 (x-Pi/2)^3 - ...
                //So if x is not Pi/2 then the closest x can get to Pi/2 is pi/2m for even n=2m, and pi/(2(2m+1)) for odd n=2m+1,
                //i.e. at least .0037... 
                //Thus, for n<=420, |cos(m23 pi /n)| is at least 0.0112 (taking n=419), if it isn't 0.
                //And, restricting to even n, about double that.

                y2 = sqrt(y);
                y3 = 1 / (2 * A);

                m23_0=-1; //used to rule out duplicate solutions from the discriminant 0 case.



                // We will determined m23 by a double precision computation, which we then rounded.
                // Is that guaranteed to produce the correct m23? Probably, but to be safe, in extreme cases
                // we compute it using quad doubles for the floating point computation.
                //
                // First, if we are given m12,m34,m13,m24,m14, then
                // m23, computed via an arccos, need not be an integer. But there's no harm in testing the gram determinant with
                // additional six-tuples. These
                // will, in all likelihood be filtered out, as the gram determinant equation is tested to
                // quad double precision (around 65 decimal places). Whatever survives through to the
                // end can then be tested algebraically.
                //
                // But what about the possibility that rounding produces the wrong m23?
                // Thus, how close is theta2 to the true theta2, i.e. how close is the acos obtained
                // from the true acos(c23), given inaccuracy in the value of c23, due to accumulated rounding errors,
                // say h, in evaluating c23.
                //
                // We thus need to estimate:
                // acos(c23+h) - acos(c23), which, by the mean value theorem, equals h/sqrt(1-c^2) for some c lying between c23 and c23+h.
                // Thus c^2< (cos(pi/420)+h)^2, since cos(pi/420) is the most extreme value for c23 in our computation.
                // |h| will be very small, less than 10^{-13}.
                // Hence c^2 < .9999440..., so that 1/sqrt(1-c^2) < 133.69.... Hence |acos(c23+h) - acos(c23)| < 140h
                //
                // How big can h be? Well, c23 is obtained as a fraction: (-B \pm sqrt(B^2 -4AC))/ (2A). We use double precision to compute the
                // numerator and denominator, and just a few dozen arithmetic operations, and a square root, involving cosines.
                //
                // Hence the numerator of c23, call it alpha, and denominator,
                // call it beta (=2A), are each generously computed to within 10^{-13}/2.
                //
                // Thus, let the computed numerator be alpha + delta_N, and the computed
                // denominator be beta + delta_D.
                //
                // Then the true value minus the computed value of alpha/beta is
                // alpha/beta - (alpha+delta_N)/(beta+delta_D) = (alpha delta_D - beta delta_N)/(beta(beta+delta_D),
                // with |delta_N| and |delta_D| both being < 10^{-13}/2.
                // Hence |alpha/beta - (alpha+delta_N)/(beta+delta_D)| < (10^{-13}/2) (|alpha|+|beta|)/(|beta||beta+delta_D|).
                // But beta=2A = c_{14}^2-1. In the most extreme case |c_14^2-1| = |cos(pi/420)^2-1| = .0000559..., so |beta| = |2A| > 10^{-4}.
                //
                // Furthermore, in our computation (|alpha|+|beta|)/(|beta|^2) < 2x10^9. (roughly).
                //
                // Thus, h < 10^{-4}. That's not quite good enough, as it only gives:
                // 140h < .014. To get m23, we multiply by n/pi, with n<=420, and then round.
                // But .014 * 420/pi =1.87... which is large enough to potentially lead to the wrong m23 being evaluated, i.e. off by up to \pm 2.
                // Odds are that the 10^{-13}/2 can be replaced by 10^{-14} in which case the error is at most 1.87/5 < .5, and there is no error
                // in computing m23. However, to be safe we can simply re-evaluate c23 and the acos in
                // quad double precision whenever (|alpha|+|beta|)/|beta|^2 > 10^8, for example.

                //
                //double DELTA0 = fabs(y2-B);
                //double DELTA1 = fabs(y2+B);
                double DELTA0 = (fabs(y2-B) + fabs(2*A))/(4*A*A);
                double DELTA1 = (fabs(y2+B) + fabs(2*A))/(4*A*A);
                double M_DELTA=max(DELTA0,DELTA1);
                int m23_1_via_qd;
                int m23_2_via_qd;


                //this is to deal with rare situation where the acos needs care to be evaluated accurately, due to the limited precision of doubles.
                //see the notes above
                if(M_DELTA>1.e8){
                  count_m23qd++;
                  c12_qd = COS_qd[n][m12];
                  c12b_qd = COSb_qd[n][m12];
                  qd_real det12_qd = one - c12b_qd;

                  c34_qd = COS_qd[n][m34];
                  c34b_qd = COSb_qd[n][m34];
                  qd_real det34_qd = det12_qd - c34b_qd + c12b_qd * c34b_qd;

                  qd_real c1234_qd = c12_qd * c34_qd;

                  c13_qd = COS_qd[n][m13];
                  c13b_qd = COSb_qd[n][m13];
                  qd_real det13_qd = det34_qd - c13b_qd;

                  qd_real c1213_qd = -two * c12_qd * c13_qd;
                  qd_real c1334_qd = -two * c13_qd * c34_qd;

                  c24_qd = COS_qd[n][m24];
                  qd_real c24b_qd = COSb_qd[n][m24];

                  qd_real c2434_qd = -two * c24_qd * c34_qd;
                  qd_real c1224_qd = -two * c12_qd * c24_qd;

                  qd_real c1213_2434_qd = c1213_qd + c2434_qd;
                  qd_real c1224_1334_qd = c1224_qd + c1334_qd;

                  qd_real c1324_qd = c13_qd * c24_qd;

                  qd_real c1324_1234_qd = c1324_qd + c1234_qd;

                  qd_real det24_qd = det13_qd - c24b_qd + c13b_qd * c24b_qd - two * c1234_qd * c1324_qd;

                  c14_qd = COS_qd[n][m14];
                  c14b_qd = COSb_qd[n][m14];

                  qd_real det14_qd = det24_qd - c14b_qd + c14_qd * c1224_1334_qd;

                  qd_real A_qd = c14b_qd - one;
                  qd_real B_qd = c1213_2434_qd - two * c14_qd * c1324_1234_qd;
                  qd_real C_qd = det14_qd;
                  y_qd = B_qd * B_qd - two*two * A_qd * C_qd;

                  if(y_qd<0) y_qd = zero;
                  qd_real y2_qd = sqrt(y_qd);
                  qd_real y3_qd = one / (two * A_qd);

                  x1_qd = (y2_qd - B_qd) * y3_qd;
                  x2_qd = -(y2_qd + B_qd) * y3_qd;
                  if(x1_qd>-.99999 && x1_qd<.99999){ //otherwise, there is no relevant acos(x1_qd) = m23 pi/n, with 1 < m23 < n
                    theta1_qd = acos(x1_qd);
                    m23_1_via_qd = to_int(nint(qd_real(n)*theta1_qd/pi_qd));
                    relevant_m23_1 = true;
                  }
                  if(x2_qd>-.99999 && x2_qd<.99999){ //otherwise, there is no relevant acos(x2_qd) = m23 pi/n, with 1 < m23 < n
                    theta2_qd = acos(x2_qd);
                    m23_2_via_qd = to_int(nint(qd_real(n)*theta2_qd/pi_qd));
                    relevant_m23_2 = true;
                  }
                }

                if(M_DELTA>max_err){
                  max_err=M_DELTA;
                  cout <<M_DELTA << " : MAX_ERR " <<endl;
                }

                cout << setprecision(15);
                // loop through the two (or one, if the discriminant is close to 0) solutions of the quadratic equation
                //for (int xx = 0; xx <= XX; xx++) {
                //
                //loop through both solutions to the quadratic equation
                for (int xx = 0; xx <= 1; xx++) {
                  if (xx == 0)
                    x2 = (y2 - B) * y3; // first solution, x2=c23, to the quadratic equation det =  A*c23b + B*c23 + C = 0
                  else
                    x2 = -(y2 + B) * y3; // second solution to the quadratic equation det =  A*c23b + B*c23 + C = 0
                  //I use xx to loop through both solutions to the quadratic equation, and store each solution as x2.
                  //Below theta2  is the corresponding acos. In qd, however, I use theta1_qd and theta2_qd to designate the two arccosines.

                  count_m23++;
                  if(relevant_m23_1||relevant_m23_2||M_DELTA<=1.e8){ //if there is a relevant m23 computed with quad double or if loss of precision in acos is not an issue

                    bool relevant_m23=false; //this one is for double precision

                    //if loss of precision is an issue for acos, use the quad double precision values
                    if(M_DELTA>1.e8){
                      if(relevant_m23_1&&xx==0) m23 = m23_1_via_qd;
                      if(relevant_m23_2&&xx==1) m23 = m23_2_via_qd;
                    }

                    //thus if M_DELTA<1.e8, so loss of precision is not relevant, check if there is a relevant acos
                    else if (x2 > -.99999 && x2 < .99999) { //otherwise, there is no relevant acos(x2) = m23 pi/n, with 1 < m23 < n

                      theta2 = acos(x2);
                      //int tmp23=(int) round(theta2 * n_over_pi);
                      m23=(int) round(theta2 * n_over_pi);
                      relevant_m23=true;
                    }

                    if((relevant_m23_1&&xx==0)||(relevant_m23_2&&xx==1)||relevant_m23){

                    
                    //if there is a relevant m23 computed using quad double precision, then compare it to a double precision computation and report if there is a mismatch.
                    //Not a big deal if there is, since if we did compute m23 using quad doubles, we continue to use that.
                    if((relevant_m23_1&&xx==0)||(relevant_m23_2&&xx==1)){
                      theta2 = acos(x2);
                      int tmp_m23=(int) round(theta2 * n_over_pi);
                      if(tmp_m23!=m23){
                          if(xx==0) cout <<"A m23 MISMATCH: " << M_DELTA<< " " << x2 << " " << x1_qd << " " << theta2 << " " << theta1_qd << " "  << m12 << " "  << m34<< " "  << m13<< " "  << m24<< " "  << m14<< " "  << m23 << " " << tmp_m23 << endl;
                          if(xx==1) cout <<"B m23 MISMATCH: " << M_DELTA<< " " << x2 << " " << x2_qd << " " <<  theta2 << " " << theta2_qd << " "  << m12 << " "  << m34<< " "  << m13<< " "  << m24<< " "  << m14<< " "  << m23 << " " << tmp_m23 << endl;
                      }

                    }


                    //In the line below, the last condition, m23!=m23_0, is always true when xx==0 since m23_0 is initialized to -1.
                    //This is how we rigorously catch a repeated root, when xx==1.
                    if (m23 >= 1 && m14 + m23 <= m13 + m24 && m23 < n && m23!=m23_0) {

                      m23_0 = m23; //store m23 as m23_0. Useful in the line above in the second round, when xx=1.

                      c23 = COS[n][m23];
                      c23b = COSb[n][m23];

                      // c1423= c14*c23;

                      // det = det14 + c23b*(c14b-1) +c23*(c1213_2434-2*c14*c1324_1234);
                      det = A * c23b + B * c23 + det14;

                      if (det < 1e-11 && det > -1e-11) {

                        c12_qd = COS_qd[n][m12];
                        c12b_qd = COSb_qd[n][m12];
                        c34_qd = COS_qd[n][m34];
                        c34b_qd = COSb_qd[n][m34];
                        c13_qd = COS_qd[n][m13];
                        c13b_qd = COSb_qd[n][m13];
                        c24_qd = COS_qd[n][m24];
                        c24b_qd = COSb_qd[n][m24];
                        c14_qd = COS_qd[n][m14];
                        c14b_qd = COSb_qd[n][m14];
                        c23_qd = COS_qd[n][m23];
                        c23b_qd = COSb_qd[n][m23];

                        Det_qd = one - c34b_qd - c23b_qd - c24b_qd - c12b_qd + c12b_qd * c34b_qd;
                        Det_qd = Det_qd - c13b_qd * (one - c24b_qd) - c14b_qd * (one - c23b_qd);
                        Det_qd = Det_qd - two * (c23_qd * c24_qd * c34_qd + c12_qd * c23_qd * c13_qd + c12_qd * c23_qd * c14_qd * c34_qd);
                        Det_qd = Det_qd - two * (c12_qd * c24_qd * c13_qd * c34_qd + c12_qd * c24_qd * c14_qd + c13_qd * c14_qd * c34_qd + c13_qd * c24_qd * c14_qd * c23_qd);
                        // check if the determinant vanishes to at least 50 decimal places
                        if (Det_qd > -1e-50 && Det_qd < 1e-50) {

                          det_11 = one - c34b_qd - c23b_qd - c24b_qd - two * c23_qd * c34_qd * c24_qd;

                          // check if the 4 principal minors are non negative to 50 decimal places
                          if (det_11 > -1e-50) {
                            det_22 = one - c34b_qd - c13b_qd - c14b_qd - two * c13_qd * c14_qd * c34_qd;
                            if (det_22 > -1e-50) {
                              det_33 = one - c14b_qd - c12b_qd - c24b_qd - two * c12_qd * c14_qd * c24_qd;
                              if (det_33 > -1e-50) {
                                det_44 = one - c12b_qd - c13b_qd - c23b_qd - two * c12_qd * c13_qd * c23_qd;
                                if (det_44 > -1e-50) {

                                  int count_diagonal_minors_that_are_zero = 0;
                                  int which_is_out = 0; // stores which of the 4 vectors is not in the same plane as the other 3.
                                                        // only relevant in the case that not all 4 are in the same plane.

                                  int sum_3; // stores the sum of the 3 vectors that lie in a plane (if they do)

                                  if (det_11 < 1e-50) {
                                    count_diagonal_minors_that_are_zero++;
                                    which_is_out = 1;
                                    sum_3 = m23 + m24 + m34;
                                  }
                                  if (det_22 < 1e-50) {
                                    count_diagonal_minors_that_are_zero++;
                                    which_is_out = 2;
                                    sum_3 = m13 + m14 + m34;
                                  }
                                  if (det_33 < 1e-50) {
                                    count_diagonal_minors_that_are_zero++;
                                    which_is_out = 3;
                                    sum_3 = m12 + m14 + m24;
                                  }
                                  if (det_44 < 1e-50) {
                                    count_diagonal_minors_that_are_zero++;
                                    which_is_out = 4;
                                    sum_3 = m12 + m13 + m23;
                                  }

                                  // check if not all 4 are lying in one plane
                                  // A diagonal minor is zero iff the 3 associated vectors
                                  // lie in a plane, so we actually only need <2 rather <4.
                                  if (count_diagonal_minors_that_are_zero < 4) {

                                    bool is_degenerate = false; // degenerate at this stage would be 3 in a plane. initialize to false.
                                    int is_perp = 0;            // to record if three in a plane and the 4th perpendicular. the integer specifies
                                                                // which vector is perpendicular, 0 being none.

                                    // check if exactly 3 lie in a plane
                                    if (count_diagonal_minors_that_are_zero == 1 && sum_3 == n) {
                                      is_degenerate = true;

                                      // check if the 4th is perpendicular by checking if it forms a right angle to the 3 in a plane
                                      if (det_11 < 1e-50) { // i.e. 1,1 diagonal minor is zero, so 2,3,4 are in a plane
                                        if (m12 == n / 2 && m13 == n / 2 && m14 == n / 2)
                                          is_perp = 1;
                                      }
                                      if (det_22 < 1e-50) { // i.e. 2,2 diagonal minor is zero, so 1,3,4 are in a plane
                                        if (m12 == n / 2 && m23 == n / 2 && m24 == n / 2)
                                          is_perp = 2;
                                      }
                                      if (det_33 < 1e-50) { // i.e. 3,3 diagonal minor is zero, so 1,2,4 are in a plane
                                        if (m13 == n / 2 && m23 == n / 2 && m34 == n / 2)
                                          is_perp = 3;
                                      }
                                      if (det_44 < 1e-50) { // i.e. 4,4 diagonal minor is zero, so 1,2,3 are in a plane
                                        if (m14 == n / 2 && m24 == n / 2 && m34 == n / 2)
                                          is_perp = 4;
                                      }
                                    } // the non-zero value of is_perp is not presently used, but hey, leave it in in case we wish
                                      // to use it later.

                                    bool proceed = false;

                                    // if: not one vector perp to the other 3 (so either 3 in a plane, but 4th not perp, or else no 3 in a plane)
                                    if (is_perp == 0)
                                      proceed = true;

                                    // however, if 3 are in a plane but the 3 corresponding angles don't add up to pi, then do not proceed
                                    if (which_is_out > 0 && sum_3 != n)
                                      proceed = false;


                                    // filter out minimally degenerate points that lie on the 8 precomputed planes and 144 lines
                                    if (proceed && is_degenerate) {

                                      soln1.n = n;
                                      soln1.m12 = m12;
                                      soln1.m13 = m13;
                                      soln1.m14 = m14;
                                      soln1.m23 = m23;
                                      soln1.m24 = m24;
                                      soln1.m34 = m34;
                                      soln1.a = a;
                                      soln1.loner = which_is_out;
                                      // not used: soln1.family=0;

                                      int countQ = 0;
                                      for (auto Q : planar_families) { // add exit once situated on a plane
                                        if (is_in_plane(soln1, Q)) {
                                          // cout <<"FOUND ON PLANE" << endl;
                                          cout << "FOUND ON PLANE " << countQ << " POINT : ";
                                          print_soln(soln1);
                                          proceed = false;
                                          break;
                                        }
                                        countQ++;
                                      }
                                      int countL = 0;
                                      for (auto L : linear_families) { // add exit condition once situated on a line
                                        if (is_on_line(soln1, L)) {
                                          cout << "FOUND ON LINE " << countL << " POINT : ";
                                          print_soln(soln1);
                                          proceed = false;
                                          break;
                                        }
                                        countL++;
                                      }
                                    }

                                    if (proceed) {

                                      newline_needed = true;

                                      a = gcd(m34, m12);
                                      if (a > 1)
                                        a = gcd(a, m13);
                                      if (a > 1)
                                        a = gcd(a, m24);
                                      if (a > 1)
                                        a = gcd(a, m14);
                                      if (a > 1)
                                        a = gcd(a, m23);
                                      if (a > 1)
                                        a = gcd(a, n);

                                      // if(a==1){

                                      if (is_degenerate) { // is minimally degenerate
                                        degenerate_solns[count_degenerate].n = n;
                                        degenerate_solns[count_degenerate].m12 = m12;
                                        degenerate_solns[count_degenerate].m13 = m13;
                                        degenerate_solns[count_degenerate].m14 = m14;
                                        degenerate_solns[count_degenerate].m23 = m23;
                                        degenerate_solns[count_degenerate].m24 = m24;
                                        degenerate_solns[count_degenerate].m34 = m34;
                                        degenerate_solns[count_degenerate].a = a;
                                        degenerate_solns[count_degenerate].loner = which_is_out;
                                        // not used: degenerate_solns[count_degenerate].family=0;
                                        cout << "count degen " << count_degenerate << " ";
                                        cout << degenerate_solns[count_degenerate].m12 << " ";
                                        cout << degenerate_solns[count_degenerate].m34 << " ";
                                        cout << degenerate_solns[count_degenerate].m13 << " ";
                                        cout << degenerate_solns[count_degenerate].m24 << " ";
                                        cout << degenerate_solns[count_degenerate].m14 << " ";
                                        cout << degenerate_solns[count_degenerate].m23 << endl;

                                        count_degenerate++;
                                      }

                                      // passes lemma 1.3A
                                      printf("A%d %d : %d %d %d %d %d %d gcd %d discr %.5e 4_diag_cofs", xx, n, m12, m34, m13, m24, m14, m23, a, y);
                                      cout << " " << setprecision(5) << det_11;
                                      cout << " " << setprecision(5) << det_22;
                                      cout << " " << setprecision(5) << det_33;
                                      cout << " " << setprecision(5) << det_44;
                                      cout << " loner " << is_degenerate << " " << which_is_out << endl;
                                      // cout << Det_qd << endl;
                                      //

                                      // check if 4 diagonal minors are positive, i.e. > 1e-50
                                      if (det_11 > 1e-50 && det_22 > 1e-50 && det_33 > 1e-50 && det_44 > 1e-50) {

                                        // passes lemma 1.3B
                                        printf("B%d %d : %d %d %d %d %d %d gcd %d discr %.5e 4_diag_cofs", xx, n, m12, m34, m13, m24, m14, m23, a, y);
                                        cout << " " << setprecision(5) << det_11;
                                        cout << " " << setprecision(5) << det_22;
                                        cout << " " << setprecision(5) << det_33;
                                        cout << " " << setprecision(5) << det_44 << endl;

                                        // not used: lemmaB_solns[count_lemmaB].family=0;
                                        lemmaB_solns[count_lemmaB].n = n;
                                        lemmaB_solns[count_lemmaB].m12 = m12;
                                        lemmaB_solns[count_lemmaB].m13 = m13;
                                        lemmaB_solns[count_lemmaB].m14 = m14;
                                        lemmaB_solns[count_lemmaB].m23 = m23;
                                        lemmaB_solns[count_lemmaB].m24 = m24;
                                        lemmaB_solns[count_lemmaB].m34 = m34;
                                        lemmaB_solns[count_lemmaB].a = a;
                                        lemmaB_solns[count_lemmaB].loner = 0; // none are out

                                        count_lemmaB++;

                                        det1 = -c12_qd * c23_qd * c34_qd - c12_qd * c24_qd - c13_qd * c34_qd - c14_qd - c23_qd * c13_qd * c24_qd + c14_qd * c23b_qd;
                                        if (det1 < -1e-50) {
                                          det2 = c23_qd * c34_qd + c24_qd + c12_qd * c13_qd * c34_qd + c12_qd * c14_qd - c13b_qd * c24_qd + c13_qd * c14_qd * c23_qd;
                                          if (det2 > 1e-50) {
                                            det3 = -c34_qd - c24_qd * c23_qd + c12b_qd * c34_qd - c12_qd * c14_qd * c23_qd - c13_qd * c12_qd * c24_qd - c13_qd * c14_qd;
                                            if (det3 < -1e-50) {
                                              // det4=det_44;
                                              // if(det4>1e-50){ //redundant because we already checked det_44 is positive

                                              // passes lemma 1.3C
                                              printf("C%d %d : %d %d %d %d %d %d gcd %d discr %.5e 4_bottom_cofs", xx, n, m12, m34, m13, m24, m14, m23, a, y);
                                              cout << " " << setprecision(5) << -det1;
                                              cout << " " << setprecision(5) << det2;
                                              cout << " " << setprecision(5) << -det3;
                                              cout << " " << setprecision(5) << det_44 << endl;
                                              // cout << " " << setprecision(5) << Det_qd << endl;

                                              // not used: lemmaC_solns[count_lemmaC].family=0;
                                              lemmaC_solns[count_lemmaC].n = n;
                                              lemmaC_solns[count_lemmaC].m12 = m12;
                                              lemmaC_solns[count_lemmaC].m13 = m13;
                                              lemmaC_solns[count_lemmaC].m14 = m14;
                                              lemmaC_solns[count_lemmaC].m23 = m23;
                                              lemmaC_solns[count_lemmaC].m24 = m24;
                                              lemmaC_solns[count_lemmaC].m34 = m34;
                                              lemmaC_solns[count_lemmaC].a = a;
                                              lemmaC_solns[count_lemmaC].loner = 0; // none are out

                                              count_lemmaB++;

                                              //}
                                            }
                                          }
                                        }
                                      }

                                      // cout << setprecision(70) << Det << endl << endl;
                                      //}

                                    } /* if is_perp==0, i.e. at least minimally degenerate */
                                  }   /* if count_diagonal_minors_that_are_zero < 4 */
                                }     /* if det_44 */
                              }       /* if det_33 */
                            }         /* if det_22 */
                          }           /* if det_11 */
                        }             // if Det_qd is small
                      }

                    } // if y>=0
                  } // if(m23>=1 && m14+m23<=m13+m24)
                 //} // if(x2>-1&&x2<1){
                 } //if((relevant_m23_1&&xx==0)||(relevant_m23_2&&xx==1)||relevant_m23){
                } //if(relevant_m23_1||relevant_m23_2||M_DELTA<=1.e8){
              }  // for xx
            }
          }
        }
      }
    } /* for m12,m13... m14. Note, m23 is now obtained directly by solving a quadratic equation */

    if (newline_needed)
      printf("\n");

  } /* for n */

  cout << "count_m23: " << count_m23 << " count_m23qd: " << count_m23qd << " ratio: " << count_m23qd*1./count_m23 << endl;

  bool is_new_family = true;
  int count_planar_families = 0;
  // systematically check all triples of solutions for planar families
  // for(k=2;k<count_degenerate-1 && count_planar_families<8 ;k++){
  for (k = 2; k < count_degenerate - 1; k++) {
    soln3 = degenerate_solns[k];
    // for(j=1;j<k && count_planar_families<8 ;j++){
    for (j = 1; j < k; j++) {
      soln2 = degenerate_solns[j];
      // for(i=0;i<j && count_planar_families<8 ;i++)
      for (i = 0; i < j; i++)
        if (soln3.loner == soln2.loner) {

          soln1 = degenerate_solns[i];

          if (soln2.loner == soln1.loner && !is_on_line(soln1, soln2, soln3)) { // first make sure the 3 solns are not on a line and that they are in the same loner class

            // then test if 5 'random' linear combinations of the 3 points satisfies det=0.
            // 5 combinations for better certainty.
            if (gives_planar_family(soln1, soln2, soln3, 2.1314, .78927598237, -.287471047) and gives_planar_family(soln1, soln2, soln3, .27384682736587, -1.871624876, 1.3517645) and
                gives_planar_family(soln1, soln2, soln3, .38623587, -1.24876, .517645) and gives_planar_family(soln1, soln2, soln3, .314, .8927598237, -.87471047) and
                gives_planar_family(soln1, soln2, soln3, .7384682736587, -.871624876, .3517645)) {
                  is_new_family = true;
                  int countQ = 0;
                  for (auto Q : planar_families) {

                    if (is_in_plane(soln1, Q) && is_in_plane(soln2, Q) && is_in_plane(soln3, Q)) {
                      is_new_family = false;
                    }
                  }
                  if (is_new_family) {

                    count_planar_families++;
                    cout << soln1.a << " ";
                    cout << soln1.m12 << " ";
                    cout << soln1.m34 << " ";
                    cout << soln1.m13 << " ";
                    cout << soln1.m24 << " ";
                    cout << soln1.m14 << " ";
                    cout << soln1.m23 << endl;

                    cout << soln2.a << " ";
                    cout << soln2.m12 << " ";
                    cout << soln2.m34 << " ";
                    cout << soln2.m13 << " ";
                    cout << soln2.m24 << " ";
                    cout << soln2.m14 << " ";
                    cout << soln2.m23 << endl;

                    cout << soln3.a << " ";
                    cout << soln3.m12 << " ";
                    cout << soln3.m34 << " ";
                    cout << soln3.m13 << " ";
                    cout << soln3.m24 << " ";
                    cout << soln3.m14 << " ";
                    cout << soln3.m23 << endl;
                    plane Q = plane(soln1, soln2, soln3);
                    planar_families.push_back(Q);
                    cout << count_planar_families << " new planar family" << endl;
                  }
            }

          } // if 3 solns are not on a line
        }
    }
  }


  for (i = 0; i < count_degenerate; i++) {

    soln1 = degenerate_solns[i];
    bool is_on_plane = false;
    for (auto Q : planar_families) { // add exit condition once is not a new family
      if (is_in_plane(soln1, Q))
        is_on_plane = true;
        break;
    }
    if (!is_on_plane)
      solns_to_process.push_back(soln1);
  }

  // for(auto soln1: solns_to_process) cout << "shit " << soln1.m12 << endl;

  
  is_new_family = true;
  int count_linear_families = 0;
  const size_t number_solns = solns_to_process.size();
  cout << "NUMBER OF SOLUTIONS NOT ON KNOWN LINES, KNOWN PLANES, OR NEW PLANES: " << number_solns << endl;

  //search for new 1 parameter families
  for (k = 2; k < number_solns; k++) {
    soln3 = solns_to_process[k];
    for (j = 1; j < k; j++) {
      soln2 = solns_to_process[j];


      // then test if 6 'random' linear combinations of the 2 points satisfies det=0.
      // 6 combinations for better certainty.
      //
      // recycle the planar_family test to see if soln2 and soln3 are in a linear family,
      // using soln2 for the first 2 points. det will still be 0
      // if both points soln2 and soln3 are on linear family.
      //

      if (gives_planar_family(soln2, soln2, soln3, 2.1314, .78927598237, -.287471047) and gives_planar_family(soln2, soln2, soln3, .27384682736587, -1.871624876, 1.3517645) and
          gives_planar_family(soln2, soln2, soln3, .14, .598237, .771047) and gives_planar_family(soln2, soln2, soln3, .4, .9798237, .1047) and
          gives_planar_family(soln2, soln2, soln3, .314, .8927598237, -.87471047) and gives_planar_family(soln2, soln2, soln3, .7384682736587, -.871624876, .3517645)) {
        is_new_family = true;
        for (auto L : linear_families) {


          if (is_on_line(soln2, L) && is_on_line(soln3, L)) {
            is_new_family = false;
          }
        }
        if (is_new_family && diff(soln2, soln3) > 1e-22) {

          cout << soln2.a << " ";
          cout << soln2.m12 << " ";
          cout << soln2.m34 << " ";
          cout << soln2.m13 << " ";
          cout << soln2.m24 << " ";
          cout << soln2.m14 << " ";
          cout << soln2.m23 << endl;

          cout << soln3.a << " ";
          cout << soln3.m12 << " ";
          cout << soln3.m34 << " ";
          cout << soln3.m13 << " ";
          cout << soln3.m24 << " ";
          cout << soln3.m14 << " ";
          cout << soln3.m23 << endl;
          count_linear_families++;
          line L = line(soln2, soln3);
          linear_families.push_back(L);
          cout << count_linear_families << " new linear family:" << soln2.loner << " " << soln3.loner << endl;
        }
      }
    }
  }
  int cnt_L;


  for (i = 0; i < number_solns; i++) {

    soln1 = solns_to_process[i];
    bool Is_on_line = false;
    for (auto L : linear_families) { // add exit condition once is not a new family
      if (is_on_line(soln1, L))
        Is_on_line = true;
        break;
    }
    if (!Is_on_line)
      sporadic_solns.push_back(soln1);
  }

  for (auto soln1 : sporadic_solns) {
    cout << "SPORADIC SOLUTION " << soln1.n << " : ";
    cout << soln1.m12 << " ";
    cout << soln1.m34 << " ";
    cout << soln1.m13 << " ";
    cout << soln1.m24 << " ";
    cout << soln1.m14 << " ";
    cout << soln1.m23 << " ";
    cout << "gcd " << soln1.a << " ";
    cout << "loner " << soln1.loner << endl;
  }

  return 0;
}

int gcd(int a, int b) {
  int r;
  if (a > b) {
    r = a;
    a = b;
    b = r;
  }
  do {
    r = (b % a);
    b = a;
    a = r;
  } while (r > 0);
  return b;
}
